import comp from "C:/Users/98301/work/yishulun_blog_mdandcode/src/.vuepress/.temp/pages/posts/2023/03.html.vue"
const data = JSON.parse("{\"path\":\"/posts/2023/03.html\",\"title\":\"Rust：为什么不能在同一个结构体中存储一个值和对该值的引用？\",\"lang\":\"zh-CN\",\"frontmatter\":{\"sidebar\":false,\"date\":\"2023-03-14T09:19:41.000Z\",\"description\":\"Rust：为什么不能在同一个结构体中存储一个值和对该值的引用？ 基本把下面问题这个搞明白，就能彻底明白 Rust 语言的生命周期是怎么回事了。简而言之，生命周期不会改变你的代码，是你的生命控制生命周期，而不是生命周期在控制你的代码。换言之，生命周期是描述性的，而不是规定性的。 原文：https://stackoverflow.com/questions...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://yishulun.com/posts/2023/03.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"艺述论\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Rust：为什么不能在同一个结构体中存储一个值和对该值的引用？\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"Rust：为什么不能在同一个结构体中存储一个值和对该值的引用？ 基本把下面问题这个搞明白，就能彻底明白 Rust 语言的生命周期是怎么回事了。简而言之，生命周期不会改变你的代码，是你的生命控制生命周期，而不是生命周期在控制你的代码。换言之，生命周期是描述性的，而不是规定性的。 原文：https://stackoverflow.com/questions...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:image\",\"content\":\"https://cdn.jsdelivr.net/gh/rixingyike/images@master/2023/202303141421810.png\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"og:updated_time\",\"content\":\"2025-02-19T00:48:07.000Z\"}],[\"meta\",{\"property\":\"article:published_time\",\"content\":\"2023-03-14T09:19:41.000Z\"}],[\"meta\",{\"property\":\"article:modified_time\",\"content\":\"2025-02-19T00:48:07.000Z\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Rust：为什么不能在同一个结构体中存储一个值和对该值的引用？\\\",\\\"image\\\":[\\\"https://cdn.jsdelivr.net/gh/rixingyike/images@master/2023/202303141421810.png\\\"],\\\"datePublished\\\":\\\"2023-03-14T09:19:41.000Z\\\",\\\"dateModified\\\":\\\"2025-02-19T00:48:07.000Z\\\",\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"李艺\\\",\\\"url\\\":\\\"https://yishulun.com\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"问题\",\"slug\":\"问题\",\"link\":\"#问题\",\"children\":[{\"level\":3,\"title\":\"C 语言示例\",\"slug\":\"c-语言示例\",\"link\":\"#c-语言示例\",\"children\":[]},{\"level\":3,\"title\":\"Rust 问题示例\",\"slug\":\"rust-问题示例\",\"link\":\"#rust-问题示例\",\"children\":[]}]},{\"level\":2,\"title\":\"引起错误的背后语法原理\",\"slug\":\"引起错误的背后语法原理\",\"link\":\"#引起错误的背后语法原理\",\"children\":[]},{\"level\":2,\"title\":\"怎么解决此类问题？\",\"slug\":\"怎么解决此类问题\",\"link\":\"#怎么解决此类问题\",\"children\":[]},{\"level\":2,\"title\":\"如何返回局部变量？\",\"slug\":\"如何返回局部变量\",\"link\":\"#如何返回局部变量\",\"children\":[]},{\"level\":2,\"title\":\"第 1 个出错示例改写（有修改）\",\"slug\":\"第-1-个出错示例改写-有修改\",\"link\":\"#第-1-个出错示例改写-有修改\",\"children\":[]},{\"level\":2,\"title\":\"小结\",\"slug\":\"小结\",\"link\":\"#小结\",\"children\":[]}],\"git\":{\"createdTime\":1678777612000,\"updatedTime\":1739926087000,\"contributors\":[{\"name\":\"LIYI\",\"username\":\"LIYI\",\"email\":\"9830131@qq.com\",\"commits\":11,\"url\":\"https://github.com/LIYI\"}]},\"readingTime\":{\"minutes\":17.97,\"words\":5391},\"filePathRelative\":\"posts/2023/03.md\",\"localizedDate\":\"2023年3月14日\",\"excerpt\":\"\\n<p>基本把下面问题这个搞明白，就能彻底明白 Rust 语言的生命周期是怎么回事了。简而言之，生命周期不会改变你的代码，是你的生命控制生命周期，而不是生命周期在控制你的代码。换言之，生命周期是描述性的，而不是规定性的。</p>\\n<blockquote>\\n<p>原文：<a href=\\\"https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct%EF%BC%8C%E4%BD%9C%E8%80%85%EF%BC%9A%5Bkmdreko%5D\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">https://stackoverflow.com/questions/32300132/why-cant-i-store-a-value-and-a-reference-to-that-value-in-the-same-struct，作者：[kmdreko]</a>(<a href=\\\"https://kmdreko.github.io/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">https://kmdreko.github.io/</a> \\\"kmdreko\\\")</p>\\n</blockquote>\",\"autoDesc\":true}")
export { comp, data }
