---
date: 2023-09-23 16:27:50
tags: ["技术栈"]
---
# Bun 1.0使用介绍（二）

继续[上一篇](https://yishulun.com/posts/2023/05.html)的内容，下面介绍Bun相比于传统技术栈框架及工具，具体有哪些优势。

## 初始化

bun的初始化简单直接，使用下列指令会直接将当前目录初始化一个bun项目工程：

```bash
bun init -y
```

参数-y代表静默，不需要提问，所有初始化产生的副任用产品都在当前目录下，所有配置在完成后都可以在文件中修改。init指令会产生lock文件、package.json文件、tsconfig.json配置文件等。bun默认使用TS作为开发语言。

## 运行指令：空间换时间

目录初始化以后会有一个index.ts文件：

```
console.log("Hello via Bun!");
```

以监听方式运行它：

```bash
bun --watch run index.ts
```

监听方式大家都懂，当我们修改源码后，bun会监测到改动并自动运行代码。这是运行单个文件，也可以在package.json中添加小脚本：

```bash
"scripts": {
   "dev": "bun --watch run index.ts"
 },
```

此时通过bun dev运行，与前一个运行指令效果是等同的。

bun有一个参数--smol，文档说加上这个参数，可以少占用内存。这让我怀疑bun在各方面之所以速度表现优秀，在于它大量采用了“空间换时间”的优化方案，它在运行之后，内存占用必定有很多。

于是，我通过活动监测器查看bun的内存占用：

![image-20230923192404581](./assets/image-20230923192404581.png)

注意，这里有两个bun，这是使用watch启动的特征，一个是守护进程，一个是真正的应用进程。上面那个PID为98344的应该是守护进程，而下面那个PID为98345的是应用程序的进程。

我分别添加--smol参数与不添加参数，做两次测试，发现内存变化寥寥。使用smol参数与否，貌似并没有明显影响内存占用。

也可能是当前这个只打印一行“hello world”的程序太简单了，下面我换一个稍微复杂的博客程序进行测试，首次是一般模式：

![image-20230923193325205](./assets/image-20230923193325205.png)

占用了约730MB内存了，好家伙，快到一个G的内存了。

然后看启用了smol模式的内存占用：

![image-20230923193548972](./assets/image-20230923193548972.png)

占用了约722MB内存！我不能说smol这个参数没有作用，毕竟同样的项目是少了几MB的。

注意，在测试的时候，前后两次使用的指令是这样的：

```bash
bun run --watch --bun vitepress dev src
bun run --smol --watch --bun vitepress dev src
```

两次的指令都加上了--bun参数，这个参数代表使用bun作为JS语言的运行时，而非默认的Node.js。

下面，我们回到vitepress的普通运行模式，不再使用bun这个运行时了，使用Node.js，指令是这样的：

```bash
bun run --watch vitepress dev src
```

或者直接使用旧脚本：

```bash
vitepress dev src
```

这是在使用Node.js作为JS的运行时，它的内存占用一下就降下来了：

![image-20230923194108099](./assets/image-20230923194108099.png)

只有182MB！

从730MB降到了182MB，**说明bun为了提高运行效率，很有可能狠狠地采用了“空间换时间”的策略**。这个世界能量是守恒的，在一个地方占优了，必然在另一个地方会有所损耗，这是肯定的。为什么别的运行时都没有smol参数，bun为什么专门搞一个smol参数？

