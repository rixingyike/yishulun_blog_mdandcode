---
createTime: 2025/02/23 20:25:00
tags: ["Rust"]
cover: https://yishulun.com/cover3.jpg
---
# 在Rust中{:?}与{:#?}有什么异同？

Rust 的格式化系统（`std::fmt`）是一个非常强大且灵活的工具，主要用于生成格式化的输出。在 Rust 的格式化输出中，`{:?}` 和 `{:#?}` 是两种常见的占位符，分别用于调试输出和美化调试输出。它们的设计和命名是基于 Rust 的格式化系统（`std::fmt`）的灵活性和扩展性考虑的。

### **1. 为什么有 `{:?}` 和 `{:#?}` 这样的定义？**

#### **(1) `{:?}`：简洁的调试输出**
- `{:?}` 是为实现 `std::fmt::Debug` trait 的类型设计的。
- 它的目标是提供一种简单、紧凑的方式来输出数据结构的内部状态，方便开发者快速查看变量的内容。
- 命名中的 `?` 表示“问号”，暗示这是用于调试的占位符。
- 冒号表示后面是格式化符号。

**设计考虑：**
- 调试输出需要尽可能详细地展示数据结构，但又不能过于冗长。
- 紧凑的格式适合简单的调试场景，例如打印单个变量或小型数据结构。

#### **(2) `{:#?}`：美化调试输出**
- `{:#?}` 是 `{:?}` 的扩展版本，用于生成更易读的输出。
- 它通过添加缩进和换行，使复杂的数据结构——如嵌套的结构体或集合，更具可读性。
- 命名中的 `#` 表示“美化”或“格式化”。

**设计考虑：**
- 对于复杂的嵌套数据结构，紧凑的输出可能难以阅读。
- 美化输出可以帮助开发者更容易理解数据的层次结构。



### **2. 开发者基于什么考虑设计这些占位符？**

#### **(1) 灵活性**
Rust 的格式化系统允许开发者根据需求选择不同的输出风格：
- `{}` 提供用户友好的输出。
- `{:?}` 提供技术性的调试输出。
- `{:#?}` 提供更美观的调试输出。

这种灵活性使得开发者可以根据场景选择合适的占位符，而无需手动调整输出格式。冒号后面还可以有其他的格式化符号，例如：

- **左对齐：**

  ```rust
  println!("{:<10}", "left"); // 左对齐，宽度为 10  
  ```

- **右对齐：**

  ```rust
  println!("{:>10}", "right"); // 右对齐，宽度为 10
  ```

- **居中对齐：**

  ```
  aaaaaaaaaaaaaaaaaaaaaaarust
  
  复制
  
  1
  q
  
  输出：q
  
  1
  qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq
    center   
  ```

  

- **自定义填充字符：**

  rust

  复制

  1

  println!("{:*^10}", "center"); // 使用 `*` 填充，居中对齐

  输出：

  复制

  1

  **center**

#### **(2) 一致性**
- `:?` 和 `#?` 的命名遵循了 Rust 格式化系统的统一规则：
  - `:` 表示这是一个特殊的格式化选项。
  - `?` 表示调试模式。
  - `#` 表示美化模式。
- 这种一致的命名方式让开发者可以轻松记住和使用这些占位符。

#### **(3) 扩展性**
Rust 的格式化系统支持自定义格式化符号，因此未来可以轻松添加新的占位符或格式化选项。例如：
- 自定义的格式化符号可以通过实现 `std::fmt::Formatter` 来支持。
- 新的占位符可以基于现有的规则进行扩展。



### **3. `{}` 中是否可以放置其他允许自定义的字符或格式符号？**

是的，Rust 的格式化系统非常灵活，支持多种自定义格式化选项。以下是一些常见的用法和扩展可能性：

#### **(1) 内置格式化选项**
Rust 提供了许多内置的格式化选项，可以直接在 `{}` 中使用。例如：
- **对齐和填充：**
  ```rust
  println!("{:<10}", "left");  // 左对齐，宽度为 10
  println!("{:>10}", "right"); // 右对齐，宽度为 10
  println!("{:^10}", "center"); // 居中对齐，宽度为 10
  ```
- **数字格式化：**
  ```rust
  println!("{:b}", 42); // 输出二进制：101010
  println!("{:x}", 255); // 输出十六进制：ff
  println!("{:e}", 1000.0); // 输出科学计数法：1e3
  ```

#### **(2) 自定义格式化**
Rust 允许开发者为自定义类型实现 `std::fmt::Display` 或 `std::fmt::Debug`，并支持自定义格式化逻辑。例如：
```rust
use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if f.alternate() {
            write!(f, "Point({},{})", self.x, self.y)
        } else {
            write!(f, "({}, {})", self.x, self.y)
        }
    }
}

fn main() {
    let p = Point { x: 10, y: 20 };
    println!("{}", p);  // 输出：(10, 20)
    println!("{:#}", p); // 输出：Point(10,20)
}
```

**解释：**
- `f.alternate()` 检查是否使用了 `#` 修饰符。
- 开发者可以根据修饰符动态调整输出格式。

#### **(3) 扩展可能性**
Rust 的格式化系统是开放的，未来可能会引入更多内置的格式化符号，或者允许开发者注册自定义的格式化规则。例如：
- 支持时间格式化（类似 Python 的 `strftime`）。
- 支持更复杂的布局控制。



### **4. 小结**

1. **`{:?}` 和 `{:#?}` 的设计考虑：**
   - `{:?}` 提供紧凑的调试输出，适合简单场景。
   - `{:#?}` 提供美化输出，适合复杂场景。
   - 命名规则（`?` 和 `#`）保持了一致性和易记性。

2. **灵活性和扩展性：**
   - Rust 的格式化系统支持多种内置选项（如对齐、数字格式化等）。
   - 开发者可以为自定义类型实现 `Display` 或 `Debug`，并支持自定义格式化逻辑。

3. **未来扩展：**
   - Rust 的格式化系统是开放的，未来可能会引入更多内置符号或支持更复杂的自定义规则。

通过这种设计，Rust 在格式化输出方面既提供了强大的功能，又保持了简洁和一致性，满足了不同场景的需求。