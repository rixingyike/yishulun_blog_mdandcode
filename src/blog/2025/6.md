---
createTime: 2025/03/01 20:25:00
tags: ["Rust"]
draft: true
---

# Rust进阶知识学习笔记

## 什么是闭包？

闭包是一种可以捕获调用者作用域变量的匿名函数。它既可以作为值赋值给变量，又可以作为实参传递给函数，它让函数变成了一种数据类型存在。还有，由于闭包不需要进行参数和返回值的类型标注，这可以省却我们不少事情。

下面这是一个好例子，cat的值是一个闭包，它捕捉了变量x。它的参数和返回值都没有类型标注，又没有fn、花括号，代码显得十分简洁。

```rust
fn main() {
   let x = 100;
   let cat = |y| x + y;
   assert_eq!(101, cat(1));
}
```

## 闭包的语法

这是闭包的正统语法：

```rust
|param1, param2...| {
    语句1;
    语句2;
    返回表达式
}
```

如果只有一行代码，花括号按约定也可以省去：

```rust
|param1,param2...| 返回表达式
```

当把一个闭包赋值给一个变量时，例如下面这个骚气的闭包：

```return
let action = || 3;
```

此时是闭包赋值给了action，并不是把闭包的执行结果赋值给了它。这一点非常浅显易知，有经验的程序员一定不会犯这样的判断错误。

谨以此例为例，action在执行之后结果仍然为3，它和`let action = 3`区别并不大，即使新学者判断失误也没有问题。

## 类型推导：先入为主

闭包不用标注参数和返回值的类型，编译器会自己推导，但是它的推导有时候会因先入为主而产生“错误”：

```rust
fn main() {
    let fn1 = |x| x;
    let s = fn1(String::from("hi"));
    let n = fn1(5);
}
```

第3行和第4行代码，谁放在后面，谁在编译时报错。**此时决定它们正确与否的关键，只是它们所站的位置不同。**闭包中的参数类型和返回值类型被推导为一种可能后，就会被一直保持为这种可能。后来的会被排斥。

怎么破解？如果我们在下面需要有不同类型参数的调用呢？

解决方法也极其简单：

```rust
fn main() {
    let s = (|x| x)(String::from("hi"));
    let n = (|x| x)(5);
    println!("s: {}", s);
    println!("n: {}", n);
}
```

闭包可以现写现用，相同的闭包代码拷贝一份即可。**代码虽然还是那个代码，但闭包已经不是那个闭包。**

## 闭包的所有权⭐

现在我们设想这样一个问题：如果我们在结构中使用了闭包，那么Rust对该闭包的所有权是如何规定的呢？

先看一则非常有Rust意味的代码示例：

```rust
struct Cache<T,E>
where 
    T: Fn(E) -> E,
    E: Copy 
{
    query: T,
    value: Option<E>,
}

impl<T,E> Cache<T,E>
where 
    T: Fn(E) -> E,
    E: Copy
{
    fn new(query: T) -> Self {
        Cache {
            query,
            value: None
        }
    }    
    fn value(&mut self, arg: E) -> E {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.query)(arg);
                self.value = Some(v);
                v 
            }
        }
    }
}
```

在结构体Cache中，query是一个闭包，它的类型是T，约束T的特征是`Fn(E) -> E`。

代码很简单，不细讲了，下面开始实践。如果我们在两个结构中实例中引用同一个闭包，会发生什么呢？程序会报错吗？

```rust
fn main() {
    let a = 1;
    let fn1 = |x| x + a;

    let mut c = Cache::new(fn1);
    println!("{}", c.value(10)); // 11
    println!("{}", c.value(11)); // 仍然是 11

    let mut d = Cache::new(fn1);
    println!("{}", d.value(10)); // 1
    println!("{}", d.value(11)); // 仍然是 10
}
```

c与d是两个Cache实例，它俩同时使用了fn1赋值query，但是程序并没有因为所有权冲突而报错。

Rust中的闭包在所有权这个议题上稍微有点复杂，究竟有没有发生所有权转移，要看闭包捕获的变量是什么情况。没有捕获或捕获的只是栈上的变量，即实现了Copy的变量，那么闭包也在栈上，并没有所有权转移，而是产生了复制（Copy），跟重写一遍闭包代码没有区别。

**如何判断闭包是不是实现了Copy特征呢？和其它复杂的类型一样，看闭包捕获的变量是不是都实现了Copy特征，如果是，则闭包也实现了Copy特征；如果否，则不是。**

对于否的这种情况，即捕猎的变量是分配在堆上的，大小是动态的，例如String，那么闭包也分配在堆上，这时候对闭包没有实现Copy特征，对它的使用就涉及到所有权转移了。

下面我们做另外一个实验，我们让闭包捕获一个String类型的变量：

```rust
#[test]
fn test() {
    let a = String::from("LY");
    // L的ascii码是76
    let fn1 = |x| x + a.chars().next().unwrap() as u8 as i32-75;
    println!("a={}", a); // 这行代码会报错

    let mut c = Cache::new(fn1);
    assert_eq!(c.value(10), 11);
    assert_eq!(c.value(11), 11);
    println!("a={}", a); // LY

    let mut d = Cache::new(fn1);
    assert_eq!(d.value(10), 11);
    assert_eq!(d.value(11), 11);
    println!("a={}", a); // LY
}
```

这个测试通过了，它没有报错。并且a一直都能打钱。为什么？

这是因为闭包fn1对a的使用，仅是引用，并没有夺取它的所有权。我们如果在闭包前面加上一个move，情况就不一样了。

```rust
let fn1 = move |x| x + a.chars().next().unwrap() as u8 as i32-75;
```

程序不能编译能过了，为什么？因为发生了所有权转移，当a被闭包占有后，后面的代码就不能再使用它了。

move的含义是：不管原来有没有发生所有权转移，加上move一定会发生所有权转移。

