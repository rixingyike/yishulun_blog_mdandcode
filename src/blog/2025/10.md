---
createTime: 2025/03/11 20:25:00
tags: ["Rust"]
draft: true
---

# Rust学习笔记3：类型

## 空类型或称永远不返回类型

感叹号写在返回值的地方，返回该函数“永远不返回类型”，在函数内部，panic可以“返回”此类型。

```rust
fn main() {
    let i = clac(5);
    println!("i = {}", i); // i = 1
}

fn clac(n:i32) -> i32 {
    match n {
        0..=10 => 1,
        _ => panic!("不合规定的值:{}", n)
    }
}
```

永远不返回类型也是任何类型，第9行，这里期待返回一个i32类型，但使用panic也能通过编译。这个类型与JS中的void类型相似。

## Sized特征与定长类型、不定长类型

出人意料的是，很多可以动态改变大小的类型，例如矢量（Vec）、字符串（String）、切片引用（&[T]）、哈希字典（HashMap），都是定长类型。它们中的元素或内容可以改变，但在编译时却拥有一个确定的长度大小，所以它们是定长类型。

而不定长类型，指的是在编译器不能确定其长度大小的类型，也叫DST（dynamically sized types）类型，在Rust中这样的类型只有三种：str、[T]、dyn Trait。对于str，它的内存是分配在静态内存区，只有运行后才知道具体占了多少内存。对于[T]，它是切片，它与切片引用（&[T]）还不同，它也无法独立使用。对于dyn Tratit，大概因为特征的具体实现是不确定的，方法中使用的类型可能有不定长类型，所以它也是不定长类型。这三种类型要使用，必须用Box等智能指针包裹起来。

所有定长类型都实现了Sized特征，反之不定长类型实现了?Sized特征。我们知道，函数的参数和返回值都要求类型和长度是固定的，但是，?Sized却可以作为参数的类型：

```rust
use std::fmt::Debug;

fn main() {
    let s1: Box<str> = "Hello!".into();
    generic(&s1);
    let s1: Box<String> = Box::new("Hello!".to_string());
    generic(&s1);
}
fn generic<T: ?Sized+Debug>(t: &Box<T>) {
    println!("t = {:?}", t);
}
```

第4行，str使用Box包裹了起来。第9行，T的类型约束就有?Sized。这个示例代码没有问题，可以运行。有人觉得String不是定长类型吗，为什么在这里仍然适用？原因在于?Sized这个特征，是一个模棱两可的特征，它代表定长类型可以，非定长类型同样也可以。

