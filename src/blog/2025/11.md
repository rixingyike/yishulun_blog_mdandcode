---
createTime: 2025/03/11 20:25:00
tags: ["Rust"]
draft: true
---

# Rust学习笔记4：

## Drop特征

使用drop方法可以回收所有权，释放内存。drop方法不需要程序员手动调用，编译器会为我们自动插入drop代码并在变量退出作用域时调用之。调用顺序是：

- 先声明的后调用，后声明的先调用；
- 在结构体内，结构体的drop先调用，继而按照字段的定义顺序调用字段的drop方法。

对于下面这个示例：

```rust
// 定义一个简单的结构体
struct Resource {
    name: String,
}

// 为 Resource 实现 Drop trait
impl Drop for Resource {
    fn drop(&mut self) {
        println!("Dropping resource: {}", self.name);
    }
}

fn main() {
    // 创建两个 Resource 实例
    let resource1 = Resource {
        name: "Resource 1".to_string(),
    };
    let resource2 = Resource {
        name: "Resource 2".to_string(),
    };

    // 创建一个作用域
    {
        let resource3 = Resource {
            name: "Resource 3".to_string(),
        };
        println!("Resource 3 is in scope");
    } // resource3 离开作用域，drop 方法被调用

    println!("End of main function");
    // resource1 和 resource2 离开作用域，drop 方法被调用
}
```

输出顺序为：

> Resource 3 is in scope
> Dropping resource: Resource 3
> End of main function
> Dropping resource: Resource 2
> Dropping resource: Resource 1

这个顺序验证了上面所讲的drop次序。

## 引用计数智能指针Rc与Arc

Rc是reference counting的缩写，是引用计数的意思，当我们使用它时，Rust会自动统计、管理引用记数，并在记数为0的时候自动将对象回收。我们可以通用Rc::clone复制对象——复制的仅仅是引用，同时让引用记数加1；可以通过Rc::string_count随时查看引用计数。

无论是Rc还是Arc，都是不可变记数引用，都不能对数据进行修改。两者在使用上没有区别，唯一的区别在于前者用于单线程内，后者用于多线程内。下面看一个Rc的示例：

```rust
use std::rc::Rc;

fn main() {
    // 创建一个 Rc 实例，引用计数为 1
    let data = Rc::new(42);

    // 克隆 Rc，引用计数增加
    let _data_clone1 = Rc::clone(&data);
    let _data_clone2 = Rc::clone(&data);

    // 打印引用计数
    println!("Reference count after cloning: {}", Rc::strong_count(&data));

    // 离开作用域，引用计数减少
    {
        let _data_clone3 = Rc::clone(&data);
        println!("Reference count inside inner scope: {}", Rc::strong_count(&data));
    }

    // 离开作用域后，引用计数恢复
    println!("Reference count after inner scope: {}", Rc::strong_count(&data));

    // 离开 main 函数，引用计数降为零，数据被清理
}
```

在这个示例中，第17行，当离开一个作用域时，引用自动减少了。记数为零时，对象即被清理。

输出结果为：

> Reference count after cloning: 3
> Reference count inside inner scope: 4
> Reference count after inner scope: 3 

再看一个Arc示例：

```rust
use std::sync::Arc;
use std::thread;

fn main() {
    // 创建一个 Arc 实例，引用计数为 1
    let data = Arc::new(42);

    // 克隆 Arc，引用计数增加
    let data_clone1 = Arc::clone(&data);
    let data_clone2 = Arc::clone(&data);

    // 打印引用计数
    println!("Reference count after cloning: {}", Arc::strong_count(&data));

    // 创建线程
    let handle1 = thread::spawn(move || {
        println!("Thread 1: Data = {}", data_clone1);
    });

    let handle2 = thread::spawn(move || {
        println!("Thread 2: Data = {}", data_clone2);
    });

    // 等待线程完成
    handle1.join().unwrap();
    handle2.join().unwrap();

    // 打印引用计数
    println!("Reference count after threads: {}", Arc::strong_count(&data));

    // 离开 main 函数，引用计数降为零，数据被清理
}
```

Arc智能指针允许移动对象进入线程内，多个线程的引用消耗会自动同步。

## Cell与RefCell

Cell充许在获取值的同时，还对值进行修改，这跳过了Rust的所有权规则。不过Cell仅针对实现了Copy的数据类型。示例：

```rust
use std::cell::Cell;

fn main() {
    // 创建一个 Cell，存储一个整数
    let value = Cell::new(42);

    // 获取 Cell 中的值（通过复制）
    println!("Initial value: {}", value.get());

    // 修改 Cell 中的值
    value.set(100);

    // 再次获取 Cell 中的值
    println!("Updated value: {}", value.get());

    // 通过 `get` 和 `set` 方法修改值
    let old_value = value.replace(200);
    println!("Replaced value: {}, Old value: {}", value.get(), old_value);

    // 使用 `into_inner` 获取 Cell 中的值（消耗 Cell）
    let final_value = value.into_inner();
    println!("Final value: {}", final_value);
}
```

这个示例会让Rust初学者感到疑惑，怎么，所有权规则不起作用了吗，一个值同时既可以获取又可以修改吗？但这种Cell仅针对实现了Copy特征的基本类型，例如上面的i32，实际上像i32这样的简单类型一般是没有必要使用Cell的。

输出为：

> Initial value: 42
> Updated value: 100
> Replaced value: 200, Old value: 100
> Final value: 200

Cell像一个世外桃园盒子，可以往里面存数据，也可以取数据，貌似还不受Rust所有权规则的约束。

RefCell用于没有实现Copy特征的，在它内部没有发生Copy，内存还是那一块内存，它只是将Rust编译器在编译时的警告延后了，如果在运行时违反了Rust规则，仍然会有panic异常。示例：

```rust
use std::cell::RefCell;

fn main() {
    // 创建一个 RefCell，存储一个 String
    let message = RefCell::new(String::from("Hello"));

    // 获取 RefCell 中的不可变引用
    {
        let msg = message.borrow();
        println!("Initial message: {}", *msg);
    } // 不可变引用离开作用域，释放借用

    // 获取 RefCell 中的可变引用并修改值
    {
        let mut msg = message.borrow_mut();
        msg.push_str(", world!");
    } // 可变引用离开作用域，释放借用

    // 再次获取 RefCell 中的不可变引用
    let msg = message.borrow();
    println!("Updated message: {}", *msg);

    // 尝试违反借用规则（会导致 panic）
    // let mut invalid_borrow = message.borrow_mut(); // 这里会 panic，因为已经有一个不可变引用
}
```

第24行，因为在第20行已经有一个不可变引用，所以这里不能再有一个可变引用，但这个错误不会在编译期报出来，只会在运行时报出来。第15行有一个可变借用，没有关系，因为到第17行它就释放了。这是使用RefCell的好处，可以跳过编译期严格的检查。

最终输出为：

> Initial message: Hello
> Updated message: Hello, world!

RefCell可以方便地实现内部可变性，当我们不方便修改第三方特征签名的时候，用RefCell的borrow_mut方法，这样可以修改数据。

Rc+RefCell可以结合起来，实现多个变量都能获得可变引用，并进行数据修改的代码。示例：

```rust
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    // 创建一个 Rc<RefCell<String>>，存储一个 String
    let data = Rc::new(RefCell::new(String::from("Hello")));

    // 克隆 Rc，增加引用计数
    let data_clone1 = Rc::clone(&data);
    let data_clone2 = Rc::clone(&data);

    // 修改 data_clone1 中的数据
    {
        let mut borrowed_data = data_clone1.borrow_mut();
        borrowed_data.push_str(", world!");
    } // 可变引用离开作用域，释放借用

    // 修改 data_clone2 中的数据
    {
        let mut borrowed_data = data_clone2.borrow_mut();
        borrowed_data.push_str(" How are you?");
    } // 可变引用离开作用域，释放借用

    // 打印最终的数据
    println!("Final data: {}", data.borrow());
}
```

Rust为了实现内存安全，在各个方向上围堵程序员的错误可能性，在实在没有办法的场景，仍然开放了像C++那样信任程序员的方法，给予了程序员自由。

2025年03月11日