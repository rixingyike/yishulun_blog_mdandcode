---
createTime: 2025/03/08 20:25:00
tags: ["Rust"]
draft: true
---

# Rust学习笔记2：for循环与迭代器等

## for循环与迭代器特征⭐

在Rust中，for循环适用于数组、切片、向量、范围、字符串、字典：

```rust
use std::collections::HashMap;
fn main() {
    // 数组
    let arr = [1, 2, 3];
    for v in arr {
        println!("{}", v); // 输出 1, 2, 3
    }
    // 切片
    let slice1 = &arr[0..2];
    for v in slice1 {
        println!("{}", v); // 输出 1, 2
    }
    // 向量
    let vec = vec![1, 2, 3];
    for v in vec {
        println!("{}", v); // 输出 1, 2, 3
    }
    // 范围（Range）
    for i in 0..=5 {
        println!("{}", i); // 输出 0, 1, 2, 3, 4, 5
    }
    // 字符串
    let s = String::from("hi");
    for c in s.chars() {
        println!("{}", c); // 输出 h, i
    }
    // 字典
    let mut map = HashMap::new();
    map.insert("a", 1);
    map.insert("b", 2);
    for (k, v) in map {
        println!("{}={}", k, v); // 输出 a=1, b=2
    }
}
```

这些集合类型之所以可以进行for循环，因为它们实现了IntoIterator trait。for循环其实是迭代器的语法糖。

Iterator自定义实现示例：

```rust
struct Counter {
  chars: String,
}
impl Counter {
  fn from(chars: String) -> Counter {
      Counter { chars }
  }
}
impl Iterator for Counter {
  type Item = char;
  fn next(&mut self) -> Option<Self::Item> {
      self.chars.pop()
  }
}
fn main() {
  let counter = Counter::from("123".to_string());
  for i in counter {
      println!("{}", i); // 输出 3 2 1
  }
}
```

结构体Counter实现了迭代器（Iterator）特征，在第17行便可以可以for关键字进行循环了。第12行，pop方法会从字符串顶部抛出字符，直到最后一个字符抛完，返回None。迭代器的结束是返回None。

上面说的是IntoIterator，这里为什么又是Iterator？前者实现的是into_iter方法，返回Iterator，然后给for进行迭代。for在循环时，真正调用的是Iterator的next方法。

## 三种迭代器特征

这三种特征是：

- into_iter：拿走所有权，for循环中的默认操作
- iter_mut：可变借用
- iter：不可变借用

下面的示例可以呈现出它们的不同：

```rust
fn main() {
    let values = vec![1, 2, 3];

    for v in values {
        println!("{}", v) // 输出 1 2 3
    }

    // 下面的代码将报错，因为 values 的所有权已经被转移走
    // println!("{:?}",values);

    let mut values = vec![1, 2, 3];
    // 对 values 中的元素进行可变借用
    let mut values_iter_mut = values.iter_mut();

    // 取出第一个元素，并修改为0
    if let Some(v) = values_iter_mut.next() {
        *v = 0;
    }
    for v in values.iter_mut() {
        *v += 1; // 每个元素都可以修改
    }
    println!("{:?}", values); // 输出 [1, 3, 4]

    let values = vec![1, 2, 3];
    for v in values.iter() {
        println!("{}", v) // 输出 1 2 3
    }
}
```

第4行，默认调用的是into_iter方法，不写也是它。第13行，调用的是iter_mut方法，所以元素可以修改。第25行，调用的是iter方法，迭代取出的元素是不可变引用。

## 消费者适配器与迭代器适配器⭐

适配器是一种经典的设计模式，在这里是两类不同的方法。对于Rust中的适配器（Iterator），返回迭代器但不执行的方法是迭代器适配器，它们的作用是链式封装；消耗迭代器并返回值的方法是消费者迭代器。

常用的消费者适配器有collect（将迭代器元素收集到Vec、HashMap等集合中）、fold（累积）、sum、count、min、max、any、all等。常用的迭代器适配器有map、filter、take、skip、zip（合二为一）、rev（反转）等。

一般情况下，在拿到迭代器之后，先调用迭代器适配器方法一个或几个，最后调用消费者适配器给操作收尾。示例：

```rust
fn main() {
    let v = vec![1, 2, 3, 4, 5];
    // 使用 map 对每个元素加 1，再使用 filter 过滤偶数
    let filtered: Vec<_> = v.iter().map(|x| x + 1).filter(|x| x % 2 == 0).collect();
    println!("Filtered: {:?}", filtered); // 输出 Filtered: [2, 4, 6]
}
```

map与filter是最经常使用的迭代器适配器方法，这类方法是惰性方法，直到最后一步collect方法，迭代器代码才开始真正执行。

## 如何拿到集合的索引？

拿到索引，在其他语言中稀松平常，但在Rust中却要费一番“周折”。示例：

```rust
fn main() {
    let v = vec![1u64, 2, 3, 4, 5, 6];
    let val = v
        .iter()
        .enumerate()
        // 每两个元素剔除一个，剩余 [1, 3, 5]
        .filter(|(index, _)| index % 2 == 0)
        .map(|(_, val)| val)
        // 累加 1+1+3+5 = 10
        .fold(1, |sum, acm| sum + acm);

    println!("{}", val);
}
```

第5行，enumerate是一个迭代器适配器方法，它会在元素前面放一个索引，并将两者包装成一个元组，重新组成新的元素。这是Rust拿到索引的方式。第10行，fold是累积方法，在这个示例中它会将各元素累积加起来，因为起始数字是1，总结果是10。

## 使用as进行类型转换

小类型向大类型转移用as：

```rust
let c = 'a' as u32; // 将字符'a'转换为整数
```

反过来不一定成功，用try_into：

```rust
fn main() {
  let a: u16 = 15;
  let b: u8 = a.try_into().unwrap(); 
  println!("{},{}",a,b); // 15,15
}
```

第3行使用了try_info，这是从哪里到哪里try呢？是从a的类型（u16）到b的类型（u8）尝试进行的类型转换。





